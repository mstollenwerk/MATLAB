function [eparam, tstats, logL, fit, fcst, weights, optimoutput] = ...
	gas_scalar_BEKK_mix_estim_targeting( R, p, q, x0, varargin )
%
%
% Michael Stollenwerk
% michael.stollenwerk@live.com
% 25.03.2021

%% Input Checking
% Will be added later
[k,~,T] = size(R);
k_ = k*(k+1)/2;
%% Optimization
obj_fun = @(param, perm_) obj_fun_wrapper(param, R(perm_,perm_,:), p, q);
% x0-----------------------------------------------------------------------
if ~isempty(x0) && (isinf(obj_fun(x0,1:k)) || isnan(obj_fun(x0,1:k)))
    error('User supplied x0 invalid.')
end
if isempty(x0)
    x0_df = [ ones(1,k).*(2*k), 5, ones(1,k).*(2*k+3), ones(1,k).*(2*k+3) ];
    x0 = [0.001*ones(1,2*p)/p, 0.98*ones(1,q)/q, .5, .5, .98, 0.001, x0_df]';
end
% Restrictions-------------------------------------------------------------
lb = [-0.001, -inf(2*p+q-1,1)', -1, -1, -0.001, -inf, fliplr(2:k+1), 2, (0:k-1), (k-(1:k)+2)]'; % itRiesz part is conjectured
ub = [inf, inf(2*p+q-1,1)', 1.001, 1.001];
% Optimization-------------------------------------------------------------
[eparam,optimoutput] = ...
    fmincon_Rieszperm(...
        k, ...
        obj_fun, ...
        x0, ...
        [],[],[],[], ...
        lb,ub,[], ...
        varargin{:} ...
    ); 
% There are finite difference problems for the weightparams when starting from 0. 
% These actually could benefit from stepsizes smaller than eps^(1/3), I think. 
% Maybe use options:
% 'FiniteDifferenceStepSize', [ones(p+q,1)*eps^(1/3);ones(4,1)*eps;ones(k+1+k+k,1)*eps^(1/3)] ... 
obj_fun_opt_perm = @(param) obj_fun(param,optimoutput.perm_);
    
% Output Creation----------------------------------------------------------
[ nLogL, logLcontr, SigmaE, ScaledScore, weights, eparam ] = obj_fun_opt_perm( eparam );
eparam.perm_ = optimoutput.perm_;

obj_fun_no_targeting = @(param) gas_scalar_BEKK_mix_likeRec( ...
        [eparam.all(1:k_); param], ...
        p, ...
        q, ...
        R(eparam.perm_,eparam.perm_,:) ...
    );
%[VCV,A,B,scores,hess,gross_scores] = robustvcv(fun, eparam, 3);
[VCV,scores,gross_scores] = vcv( obj_fun_no_targeting, eparam.all(k_+1:end) );
tstats = eparam.all(k_+1:end)./sqrt(diag(VCV));


aic = 2*nLogL + 2*(numel(x0)+k_);
bic = 2*nLogL + log(T)*(numel(x0)+k_); % see Yu, Li and Ng (2017) 
logL_detR_part = -(k+1)/2*sum(logdet3d(R));
logL = struct(...
    'logL', -nLogL,...
    'logL_detR_part', logL_detR_part, ...
    'aic', aic,...
    'bic', bic,...
    'logLcontr', logLcontr...
);

fit = struct( ...
    'SigmaE', SigmaE(:,:,1:T), ...
    'ScaledScore', ScaledScore, ...
    'weights', weights.weights(1:T), ...
    'score_weights', weights.score_weights ...
);
fcst = struct('SigmaE', SigmaE(:,:,T+1:end), 'weights', weights.weights(T+1:end));

end

function [ nLogL, logLcontr, SigmaE, ScaledScore, weights, param_out, fitplot ] = obj_fun_wrapper(param, R, p, q) 

    if sum(param(2*p+1:2*p+q)) >= 1
        nLogL = inf;   
        return
    end
    
    meanSig = mean(R,3);
    
    vechcholIntrcpt = vechchol( meanSig*(1-sum(param(2*p+1:2*p+q))) );  
    
    [ nLogL, logLcontr, SigmaE, ScaledScore, weights, param_out, fitplot ] = gas_scalar_BEKK_mix_likeRec( ...
        [vechcholIntrcpt; param], ...
        p, ...
        q, ...
        R ...
    );

end